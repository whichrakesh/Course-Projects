<html>
<head>
<link href="http://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet" type="text/css">
<title>g26_prof_report</title><style>
body{margin-right:10em; margin-left:10em;font-family: "Open Sans", sans-serif;}h1{text-align:center;color:#339933;text-transform:capitalize;}.center{margin-right:auto; margin-left:auto;text-align:center;}.subsection{font-size:25;text-align:center;color:#336633;text-transform:capitalize;}</style></head>
<body>
<h1>Profiling Report for CS296 Project simulation</h1>We simulated our design without GUI by removing all calls to GLUI and GLUT cite{lab05}. In the main function, We calculated the average of many quantities like 
step time, collision update time, velocity update time and position update time based on the profile of m_world imported from base_sim_t.
Based on the data received from the world profile we plotted graphs showing the relationship between many quantities like step time vs iteration etc. 
using Gnuplot and Matplotlibcite{lab09}. As Matplotlib graphs are more clear, we considered showing them. We will try to explain the variations in the graphs
by simulating the environment again by adding GUI. 
We plotted the graphs first by simulating our machine with even terrain for 150 iterations and 15 reruns. Then we gave random uneven terrain and 
placing obstacles at random locations in each rerun which we generated by seeding rand value to time at the moment. Then we removed the srand() 
function call, and ran our source code for 1200 iterations and 150 reruns to get a good view of what is actually happening as the terrain is uneven 
now but not random. We gave some initial motor speed to wheels and other joints so that it will simulate automatically without keyboard callbacks.

</br><div class="subsection">Step time and loop time vs Number of Iterations</div>	The loop time is the total time for the 'for' loop for ''iteration number" counts, therefore it increases almost lineary with iteration number 
	with slight variation in between. As it is generated using getTimeOfDay() function, it depends on other processes running at that point of time.
	As the avg. step time for various iteration counts are much smaller than that of avg. loop time in the later part of the graph, the plot for 
	avg. step time is not much clearer. 	
<div class="center"><div><img src="images/g26_plot00_150x10_even.png" /></div></div><div class="center"><div><img src="images/g26_plot00_1500x10_random.png" /></div></div><div class="center"><div><img src="images/g26_plot00_1200x150_uneven.png" /></div></div>	
</br><div class="subsection">Average step time, collision time, velocity time, position time and total time vs Number of Iterations</div>	The average step time, collision time ,velocity time ,position time and total time have almost similar profiles. Their values, on an average, decrease with 
	the number of iterations at first and at some points there are sudden variations in the graph which are produced by collision. The avg. step time  
	is more than the sum of avg. collision time, avg. velocity time and avg. position time throughout the graph. The variations are more in the data generated
	for random terrain. In the third plot, graph goes smooth upto 180 then variation occurs. This can be explained by change in the terrain which result in more 
	step times due to more position, velocity and collision updates.
<div class="center"><div><img src="images/g26_plot01_150x10_even.png" /></div></div><div class="center"><div><img src="images/g26_plot01_1500x10_random.png" /></div></div><div class="center"><div><img src="images/g26_plot01_1200x150_uneven.png" /></div></div>	
</br><div class="subsection">Avg. step time with standard deviations vs iteration numbers</div>	The errors corresponding to greater step times are more than those of smaller step times. This can be explained by looking at the point graph of average 
	step time with iteration count as discussed later in the section. At the point of variation, some points lie far above other points in the graph which 
	result in greater avg. step time as well as more error.
<div class="center"><div><img src="images/g26_plot02_150x10_even.png" /></div></div><div class="center"><div><img src="images/g26_plot02_1500x10_random.png" /></div></div><div class="center"><div><img src="images/g26_plot02_1200x150_uneven.png" /></div></div>	
</br><div class="subsection">Step Time Frequency Plot</div>	As is evident from the graph, for some small iteration count the distribution of step time is almost similar for both even terrain and random uneven terrain 
	because both terrains are even for some distance after which random terrain is created. The third graph shows that there are some points which lie far away 
	from their partners which result in more error.
<div class="center"><div><img src="images/g26_plot03_150x10_even.png" /></div></div><div class="center"><div><img src="images/g26_plot03_1500x10_random.png" /></div></div><div class="center"><div><img src="images/g26_plot03_1200x150_uneven.png" /></div></div>	
</br><div class="subsection">step time vs number of iterations : point graph</div>	For the first two graphs as the number of reruns per iteration is less than 15, We only plotted the point graph for step time of each rerun. Most of 
	the points in the first graph lie on a curve though at some points they deviate due to collision or extreme constraints. In the second graph, the points 
	form many curves  which can be explained by the fact that when segments change due to randomness in y1, the effective step time increases due to the 
	change in the terrain at the moment. As the value of y1 be -1 or 0, the curve would deviate at the intersection point if there is a change in y1. So, this 
	behaviour of the graph is expected.
	
<div class="center"><div><img src="images/g26_plot04_150x10_even.png" /></div></div><div class="center"><div><img src="images/g26_plot04_1500x10_random.png" /></div></div><div class="center"><div><img src="images/g26_plot04_1200x150_uneven.png" /></div></div>	
</body>
</html>